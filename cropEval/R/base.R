#' Multi-trait phenotypic correlation
#'
#' Computational phenotypic correlation.
#'
#' @param datdf A data frame format, phenotype data or BLUE data, The column needs to contain 'Name','Location','Field','Type', 'Trait'.
#' @param trait.vec The set of traits to be analyzed.
#' @param ped Pedigree file with three columns (ID, FGenoId, MGenoID).
#' @param ainv Inverse matrix of the genealogical matrix generated by asreml::ainverse(ped).
#' @param verbose Whether to display the output information.
#' @return Phenotypic correlation matrix of different traits.
#' @examples
#' data("TestAinv")
#' data("TestPed")
#' data("TestBlueList")
#' filter.res <- dataOutliers.for(data   = phdemo$SpML,
#'                                traits = c('MST',"YLD","PHT","EHT"),
#'                                model  = '3SD')
#' testCor <- mulTraitEstimation(datdf = filter.res$result_df,
#'                               trait.vec = c("YLD", "MST.x", "MST.y", "PHT", "EHT"),
#'                               ainv = ainv, ped = ped)
#' testCor
#' @export mulTraitEstimation

mulTraitEstimation <- function(datdf, trait.vec, ped = NULL, ainv = NULL, verbose = TRUE){

    message("分析不同性状间的遗传相关....")

    if (!all(c('Name','Location','Field','Type') %in% names(datdf))){
        stop('Not all necessary columns are included in data frame\n')
    }
    # message('-------------------检查数据-------------------\n')
    datdf       <- datdf[!is.na(datdf$Name),]
    TagTraitIdx <- sapply(trait.vec,
                          FUN = function(x){
                              tmp <- which(x == colnames(datdf))
                              if(length(tmp) == 0) stop(paste0("不存在 ", x, " 性状"))
                              return(tmp)
                          })
    trait_num   <- length(unlist(TagTraitIdx))
    if(trait_num <= 1) stop("需要输入多个性状")
    if(is.null(ped) & is.null(ainv)) stop("ped和ainv都是NULL")
    if(!is.null(ped)){
        names(ped)  <- c('ID','FGenoID','MGenoID')
        ped$ID      <- toupper(ped$ID)
        ped$FGenoID <- toupper(ped$FGenoID)
        ped$MGenoID <- toupper(ped$MGenoID)
        if(length(which(ped$ID %in% datdf$Name)) == 0) stop("系谱文件有误，未在系谱文件中找到datdf数据中的Name")
    }
    if(is.null(ainv)){
        ainv <- ainverse(ped)
    }

    datdf$Name <- toupper(datdf$Name)
    corMat <- matrix(NA, nrow = trait_num, ncol = trait_num)
    diag(corMat) <- 1
    colnames(corMat) <- row.names(corMat) <-  trait.vec

    for (t1 in 1:(trait_num-1)) {
        for (t2 in (t1+1):trait_num) {
            message(paste0("正在分析 ", trait.vec[t1], " 与 ", trait.vec[t2], " 的相关性...."))
            asr_data <- data.frame(Name   = datdf$Name, Location = datdf$Location, Field = datdf$Field,
                                   trait1 = datdf[,TagTraitIdx[t1]],
                                   trait2 = datdf[,TagTraitIdx[t2]])
            asr_data$Name <- as.factor(asr_data$Name)
            asr_data$Field    <- as.factor(asr_data$Field)
            asr_data$Location <- as.factor(asr_data$Location)
            mod = asreml(cbind(trait1,trait2) ~ trait + trait:Location +
                             trait:Field,
                         random = ~ us(trait):vm(Name,ainv),
                         residual = ~ units:us(trait),
                         data=asr_data)

            iter <- 1
            while(!mod$converge & (iter < 10)){
                message("更新 mgxe 迭代第 ", iter, " 次")
                mod  <- update(mod)
                iter <- iter + 1
            }
            print(summary(mod)$varcomp)

            rg  <- vpredict(mod,rg~V2/sqrt(V1*V3))

            rg$trait1 <- trait.vec[t1]
            rg$trait2 <- trait.vec[t2]
            rg$converge <- mod$converge
            # genetCorr <- rbind(genetCorr,rg)
            print(rg)
            corMat[t1, t2] <- rg$Estimate
            corMat[t2, t1] <- rg$Estimate
        }
    }
    return(corMat)
}

#' Multipoint (Location) joint analysis, BLUP EBV
#'
#' This function uses multiple locations to estimate the EBV values of the F_parent and the M_parent.
#'
#' @param datdf A data frame format, phenotype data or BLUE data, The column needs to contain 'Name','Location','Field','Type', 'Trait'.
#' @param trait Target traits to be analyzed.
#' @param ped Pedigree file with three columns (ID, FGenoId, MGenoID).
#' @param ainv Inverse matrix of the genealogical matrix generated by asreml::ainverse(ped).
#' @param loc.grp.by Group locations.
#' @param verbose Whether to display the output information.
#' @return Output the EBV values of parents in different environments.
#' @examples data('TestPheno')
#' data('TestAinv')
#' data('TestPed')
#' data("TestBlueList")
#' controlList <- list(Region   = "EM",
#'                     Trait    = list(name = c("YLD", "MST", "PHT", "EHT"),
#'                     max = c(10000, 10000, 10000, 10000),
#'                     min = c(0, 0, 0, 0)),
#'                     Location = c("6HLJSC", "6JLDF", "6JLDH", "6JLGZL", "7LNTL", "7NMTL"),
#'                     Field    = c(1:8),
#'                     Type     = c("P1", "P3", "PLate"),
#'                     FilterStd = 3)
#' filterRes <- filterDat(dat = phdemo[[1]], control = controlList)
#' grp.by  <- list(Spring=c("6JLGZL","7NMTL","7LNTL"),
#'                 Summer=c("6HLJSC", "6JLDF", "6JLDH"))
#' testGxE <- mgxeEstimation(datdf = filterRes$filterData,
#'                           trait = "PHT",
#'                           ped   = ped,
#'                           ainv  = ainv,
#'                           loc.grp.by = grp.by)
#' plot(testGxE$mgxe$F.EBV.Spring$EBV, testGxE$mgxe$F.EBV.Summer$EBV)
#' plot(testGxE$mgxe$M.EBV.Spring$EBV, testGxE$mgxe$M.EBV.Summer$EBV)
#' @export mgxeEstimation

mgxeEstimation <- function(datdf, trait, ped = NULL, ainv = NULL, loc.grp.by = NULL, verbose = TRUE){

    message("G x E分析中将不同的 Location 作为不同的环境因子")

    if (!all(c('Name','Location','Field','Type') %in% names(datdf))){
        stop('Not all necessary columns are included in data frame\n')
    }
    # message('-------------------检查数据-------------------\n')
    datdf       <- datdf[!is.na(datdf$Name),]
    if(length(trait)!=1) stop("单性状分析")
    TagTraitIdx <- which(colnames(datdf) == trait)
    if(length(TagTraitIdx) == 0)     stop(paste0("没有找到 ", trait, " 性状!"))
    if(is.null(ped) & is.null(ainv)) stop("ped和ainv都是NULL")
    if(!is.null(ped)){
        names(ped)  <- c('ID','FGenoID','MGenoID')
        ped$ID      <- toupper(ped$ID)
        ped$FGenoID <- toupper(ped$FGenoID)
        ped$MGenoID <- toupper(ped$MGenoID)
        if(length(which(ped$ID %in% datdf$Name)) == 0) stop("系谱文件有误，未在系谱文件中找到datdf数据中的Name")
    }
    if(is.null(ainv)){
        ainv <- ainverse(ped)
    }
    #------------------------------------------------------------
    # if(length(unique(datdf$Location)) != 1) stop("Location数量 > 1，空间校正（BLUE分析）的分析单位是小区")
    # if(length(unique(datdf$Field)) != 1)    stop("Field > 1，空间校正（BLUE分析）的分析单位是小区")
    # if(length(unique(datdf$Type)) != 1)     stop("Type > 1，空间校正（BLUE分析）的分析单位是小区")
    # if(length(datdf$Name) != length(unique(datdf$Range))*length(unique(datdf$Pass)))     stop("")
    colnames(datdf)[TagTraitIdx] <-  "trait"

    datdf$Name <- toupper(datdf$Name)
    datdf$Name <- as.factor(datdf$Name)

    datdf$LF   <- paste0(datdf$Location,'_',datdf$Field)
    datdf$LF   <- as.factor(datdf$LF)
    site <- rep(NA, dim(datdf)[1])
    if(!is.null(loc.grp.by)){
        grpname <- NULL
        for (grp in 1:length(loc.grp.by)) {
            listx  <- loc.grp.by[grp]
            idxTmp <- which(datdf$Location %in% unlist(listx))
            if(length(idxTmp)!=0){
                site[idxTmp] <- names(listx)
                grpname <- paste0(grpname, ".", names(listx))
            }else{
                stop(paste0("不存在的Location: ", listx))
            }
        }
        if(length(which(is.na(site))) != 0){
            if("other" %in% names(loc.grp.by)){
                site[which(is.na(site))] <- grpname
                loc.grp.by <- c(loc.grp.by, list(grpname))
                names(loc.grp.by)[length(loc.grp.by)] <- grpname
            }else{
                site[which(is.na(site))] <- "other"
                loc.grp.by <- c(loc.grp.by, list(other = "other"))
            }
        }
    }else{
        #没有提供分组信息，直接按照所有的Location划分Site
        LocType <- names(table(datdf$Location))
        loc.grp.by <- list()
        for (grp in 1:length(LocType)) {
            idxTmp <- which(datdf$Location %in% LocType[grp])
            site[idxTmp] <- paste0("set", grp)
            loc.grp.by[grp]  <- LocType[grp]
        }
        names(loc.grp.by) <- paste0("set", 1:length(LocType))
        site[which(is.na(site))] <- paste0("set", grp+1)
    }
    # length(which(is.na(datdf$YLD)))/dim(datdf)[1]
    datdf$site <- site
    datdf <- datdf[order(datdf$site), ]
    datdf$site <- as.factor(datdf$site)
    #

    mgxe <- asreml(trait~LF+site,
                   random   = ~us(site):vm(Name,ainv),
                   residual = ~dsum(~id(units)|site),
                   data     = datdf)
    iter <- 1
    while(!mgxe$converge & (iter < 10)){
        message("更新 mgxe 迭代第 ", iter, " 次")
        mgxe  <- update(mgxe)
        iter <- iter + 1
    }
    print(summary(mgxe)$varcomp)
    va <- summary(mgxe)$varcomp
    var_name <- row.names(va)
    #==================================
    #TODO:这里需要明确相关结果的含义
    rg   <- vpredict(mgxe,rg ~ V2/sqrt(V1*V3))
    h2sp <- vpredict(mgxe,h2~V1/(V1+V4))
    h2su <- vpredict(mgxe,h2~V3/(V3+V5))
    h2sp$season <- 'Spring'
    h2su$season <- 'Summer'
    h2   <- rbind(h2sp,h2su)
    h2
    rg

    if(!is.null(ped)){
        fgenoid  <- unique(ped$FGenoID)
        mgenoid  <- unique(ped$MGenoID)
        febvres <- list()
        mebvres <- list()
        for (grp in 1:length(loc.grp.by)) {
            grpname   <- names(loc.grp.by[grp])
            grpVarIdx <- which(str_count(string = var_name, pattern = grpname) == 2)

            Febvs  <- gxe.extracting(asr=mgxe,var=va$component[grpVarIdx],
                                     individual = fgenoid,
                                     term=paste0(grpname,':vm(Name, ainv)*'),
                                     gxe=TRUE)
            Mebvs  <- gxe.extracting(asr=mgxe,var=va$component[grpVarIdx],
                                     individual = mgenoid,
                                     term=paste0(grpname,':vm(Name, ainv)*'),
                                     gxe=TRUE)

            Febvs   <- Febvs[order(-Febvs$EBV),]
            Febvs$par <- grpname
            febvres <- c(febvres, list(Febvs))

            Mebvs   <- Mebvs[order(-Mebvs$EBV),]
            Mebvs$par <- grpname
            mebvres <- c(mebvres, list(Mebvs))

        }
        names(mebvres) <- paste0('M.EBV.', names(loc.grp.by))
        names(febvres) <- paste0('F.EBV.', names(loc.grp.by))

    }
    #==================================
    if(verbose){
        # title <- paste(reg,trait,'BLUE: Location =',
        #                unique(datdf$Location)[1],
        #                ' Field =',unique(datdf$Field)[1],
        #                ' H2 =',round(H2[1,1],2),'N =',nrow(datdf),
        #                '\n')

        ggplot() +
            geom_point(aes(x=febvres$F.EBV.Spring$EBV, y=febvres$F.EBV.Summer$EBV)) +
            geom_smooth(formula = y ~ x, method='lm',se=FALSE) + #layer 2
            ggtitle('GxE模型')+
            labs(y="EBV of Summer breeds",
                 x="EBV of Spring breeds") +
            theme(plot.title=element_text(size=15, face="bold"),
                  axis.text.x=element_text(size=8),
                  axis.text.y=element_text(size=8),
                  axis.title.x=element_text(size=10),
                  axis.title.y=element_text(size=10),
                  legend.position = 'none')
    }
    outlist <- list(mgxe=c(febvres, mebvres),asr=mgxe)
    message('MGxE estimation is successful...\n')
    return (outlist)
}

gxe.extracting <- function(asr,var,individual,term,gxe=FALSE) {
    ebv <- summary(asr,coef=T)$coef.random
    ebv <- as.data.frame(ebv)
    bvalue <- as.data.frame(ebv[grepl(term,row.names(ebv)),])

    head(bvalue)
    dim(bvalue)
    bvalue$id <- 0
    for (i in 1:dim(bvalue)[1]){
        s <- strsplit(row.names(bvalue)[i],"[_]")[[1]]
        if (gxe){
            bvalue$id[i] <- s[3]
        } else {
            bvalue$id[i] <- s[2]
        }
    }
    v <- (1-bvalue$'std.error'^2/var)
    bvalue$rel <- ifelse(v<=0,0,v)
    bvalue$acc <- sqrt(bvalue$rel)

    bvalue <- bvalue[bvalue$id %in% individual,]
    bvalue <- bvalue[,c(4,1,2,5,6)]
    row.names(bvalue) <- seq(1:nrow(bvalue))
    names(bvalue) <- c("ID","EBV","se","rel","acc")
    print(head(bvalue))

    return(bvalue)

}

#' Filter the raw data
#'
#' The function is used for preliminary filtering of raw data, including:
#' 1. filtering out the outlier specified by the user;
#' 2. Process phenotypic outliers according to different Location, Field and Type (filter out outliers beyond n times
#' standard deviation).
#'
#' @param dat A data.frame format, The column name must contain 'Name','Range','Pass','Location','Field','Set','Type'.
#' @param control A list format, Extract the Trait, Locatiton, Field, and Type provided in the control list; Discard
#' outliers beyond n times (FilterStd) standard deviation.
#' @param verbose Whether to display the output information.
#' @return Returns a list contains: A data frame containing columns for Name, Range, Pass, Location, Field, Type, Set,
#' trait,
#'   Qualified(Data conformity); A grouped data frame containnig columns for Location, Field, Type, Number(The number
#'   of samples in the group), unique_Range(Line number), unique_Pass(Column number), Pass(|Range| x |Pass| ?= |Name|),
#'   QCRate(Effective data volume).
#'
#' @examples data("TestPheno")
#' controlList <- list(Region   = "EM",
#'                     Trait    = list(name = c("YLD", "MST", "PHT", "EHT"),
#'                                     max = c(10000, 10000, 10000, 10000),
#'                                     min = c(0, 0, 0, 0)),
#'                     Location = c("6HLJSC", "6JLDF", "6JLDH", "6JLGZL", "7LNTL", "7NMTL"),
#'                     Field    = c(1:8),
#'                     Type     = c("P1", "P3", "PLate"),
#'                     FilterStd = 3)
#' filterRes <- filterDat(dat = phenos[[1]], control = controlList)
#' filterRes$summary
#' @export filterDat

filterDat   <- function(dat, control = list(), verbose = TRUE){

    message("Filtering... ")

    if(!all(c('Name','Range','Pass','Location','Field','Set','Type',control$Trait$name) %in% names(dat))) stop("Please Check your Data!")

    #TODO:输写格式规范化
    if(is.null(control$Trait))    stop("Trait is null!")
    if(is.null(control$Location)) stop("Location is null!")
    if(is.null(control$Field))    stop("Field is null!")
    if(is.null(control$Type))     stop("Type is null!")

    message("Data Location Information:",appendLF = F);     print(table(dat$Location))
    message("Control Location Information:",appendLF = F);  print(control$Location); cat("\n")

    message("Data Field Information:",appendLF = F);     print(table(dat$Field))
    message("Control Field Information:",appendLF = F);  print(control$Field); cat("\n")

    message("Data Type Information:",appendLF = F);    print(table(dat$Type))
    message("Control Type Information:",appendLF = F); print(control$Type); cat("\n")

    filterDat <- dat %>% dplyr::select(c(Name,
                                         Range,
                                         Pass,
                                         Location,
                                         Field,
                                         Type,
                                         Set,
                                         control$Trait$name)) %>%
        dplyr::filter(Location %in% control$Location) %>%
        dplyr::filter(Field    %in% control$Field) %>%
        dplyr::filter(Type     %in% control$Type)  %>%
        dplyr::mutate(Qualified = TRUE)

    if(dim(filterDat)[1]==0){
        warning("The data is empty after filtering! May not have been planted! ")
        return(NULL)
    }
    filterDatG <- group_by(filterDat, Location, Field, Type)
    #TODO:根据不同的类型（例如地块、小区）分别进行处理,这里是先过滤n倍标准差，还是先按用户的阈值过滤数据
    for (j in 1:length(control$Trait$name)) {
        if(!is.null(control$FilterStd)){
            colnames(filterDatG)[7+j] <- paste0("TagTrait")
            newTransTmp <- mutate(filterDatG,
                                  GrpMean = mean(TagTrait),
                                  GrpStd  = sd(TagTrait))
            StdFilter <- filterDatG$TagTrait < newTransTmp$GrpMean+control$FilterStd*newTransTmp$GrpStd
            filterDat <- filterDat %>% dplyr::mutate(Qualified = StdFilter)
            colnames(filterDatG)[7+j] <- colnames(filterDat)[7+j]
        }
        trait       <- control$Trait$name[j]
        tmp_1       <- (filterDat %>% dplyr::select(trait) <= control$Trait$max[j]) & filterDat$Qualified
        tmp_2       <- (filterDat %>% dplyr::select(trait) >= control$Trait$min[j]) & filterDat$Qualified
        tmp         <- (tmp_1&tmp_2)
        filterTmp   <- filterDat %>% dplyr::select(trait)
        filterTmp[!tmp] <- NA
        colnames(tmp)   <- "Qualified"
        filterDat <- filterDat %>% dplyr::mutate(Qualified = tmp, filterTmp)
    }
    #检查数据，|Range| x |Pass| != |Name|
    checkRmulP <- function(name, r, p){ return((length(name) == length(unique(r))*length(unique(p)))) }
    #表型过滤后非NA比例
    QC_Rate    <- function(x){ length(which(x))/length(x) }
    #对过滤后的信息进行统计
    filterDatG <- group_by(filterDat, Location, Field, Type)

    DataSummary <- summarise(filterDatG, Number = n(),
                             unique_Range = n_distinct(Range),
                             unique_Pass  = n_distinct(Pass),
                             Pass    = checkRmulP(Name, Range, Pass),
                             QCRate  = QC_Rate(Qualified))
    if(verbose){
        print(DataSummary)
        head(filterDat)
    }
    return(list(summary = DataSummary,
                filterData = filterDat))
}

#' Spatial correction (BLUE analysis)
#'
#' :
#'
#' @param datdf
#' @param trait
#' @param na.max
#' @param fix.factor
#' @param min.valid.range
#' @param min.valid.pass
#' @param verbose
#' @return
#' @examples
#' @export blueEstimationY

blueEstimationY <- function(datdf, trait, na.max = 0.9, fix.factor = "all", min.valid.range = 2, min.valid.pass = 2, verbose = TRUE){

    if (!all(c('Name','Range','Pass','Location','Field','Set','Type') %in% names(datdf))){
        stop('Not all necessary columns are included in data frame\n')
    }
    # message('-------------------检查数据-------------------\n')
    datdf       <- datdf[!is.na(datdf$Name),]
    TagTraitIdx <- which(colnames(datdf) == trait)
    if(length(TagTraitIdx) == 0)            stop(paste0("没有找到 ", trait, " 性状!"))
    if(length(unique(datdf$Location)) != 1) stop("Location数量 > 1，空间校正（BLUE分析）的分析单位是小区")
    if(length(unique(datdf$Field)) != 1)    stop("Field > 1，空间校正（BLUE分析）的分析单位是小区")
    if(length(unique(datdf$Type)) != 1)     stop("Type > 1，空间校正（BLUE分析）的分析单位是小区")
    if(length(datdf$Name) != length(unique(datdf$Range))*length(unique(datdf$Pass)))     stop("Type > 1，空间校正（BLUE分析）的分析单位是小区")

    colnames(datdf)[TagTraitIdx] = "trait"
    datdf$Range <- as.factor(datdf$Range)
    datdf$Pass  <- as.factor(datdf$Pass)
    datdf$Name  <- as.factor(datdf$Name)
    datdf$Set   <- as.factor(datdf$Set)

    # message('-------------------正在进行空间分析-------------------\n')

    length(unique(datdf$Range))

    TransMat <- tidyr::spread(data.frame(Range = datdf$Range, Pass = datdf$Pass, Trait = datdf$trait),
                              key = Pass,
                              value = Trait)
    row.names(TransMat) <- TransMat[,1]
    TransMat <- TransMat[,-1]
    Range.Na <- apply(TransMat, 1, FUN = function(x){return(length(which(is.na(x)))/length(x))})
    Pass.Na  <- apply(TransMat, 2, FUN = function(x){return(length(which(is.na(x)))/length(x))})

    message("行区中缺失率最高的为：第 ", names(Range.Na)[which.max(Range.Na)], " 行 ，缺失率为：", Range.Na[which.max(Range.Na)])
    message("列区中缺失率最高的为：第 ", names(Pass.Na)[which.max(Pass.Na)], " 列，缺失率为：", Pass.Na[which.max(Pass.Na)])
    #
    Total.Sample <- nrow(datdf)
    Na.Rate      <- 1 - nrow(datdf[!is.na(datdf$trait),])/Total.Sample
    valid.rnum   <- length(which(Range.Na < na.max))
    valid.pnum   <- length(which(Pass.Na < na.max))
    #不做分析
    if(Na.Rate > na.max){
        message('BLUE not estimable due to only one Range','\n')
        H2 <- data.frame(Estimate=NA,SE=NA,Location=unique(datdf$Location)[1],
                         Field=unique(datdf$Field)[1],Type=datdf$Type[1],N=nrow(datdf))
        blue <- data.frame(Name            = datdf$Name,
                           predicted.value = datdf$trait,
                           std.error       = NA,
                           status          = 'unestimable',
                           Location        = unique(datdf$Location)[1],
                           Field           = unique(datdf$Field)[1],Type=datdf$Type[1],
                           N               = nrow(datdf),
                           converge        = 'NA')
        print(head(blue))
        asr <- NULL
        title <- paste(reg,trait,'BLUE is not estimable:  Location =',
                       unique(datdf$Location)[1],
                       ' Field =',unique(datdf$Field)[1],
                       'N =',nrow(datdf),
                       '\n')

    }else if(valid.rnum <= min.valid.range || valid.pnum <= min.valid.pass){
        #方差分析
        message('有效行/列的数量不足，使用方差分析 \n asr <- asreml(trait ~ 1,random = ~idv(Name),
                              residual = ~idv(units), data = datdf)\n')
        asr <- asreml(trait ~ Range + Pass,random = ~idv(Name),
                      residual = ~idv(units), data = datdf)
    }else{
        if(!all(fix.factor %in% c('none','all','Range','Pass') )) stop("空间校正时，固定因子（fix.factor）的可选选项为 'none','all','Range','Pass'")
        #Range和Pass不作为固定效应
        if(fix.factor == "none"){
            message('asr <- asreml(trait ~ 1,random = ~idv(Name),
                              residual = ~ar1(Range):ar1(Pass), data = datdf)\n')
            asr <- asreml(trait ~ 1,random = ~idv(Name),
                          residual = ~ar1(Range):ar1(Pass), data = datdf)
        }
        #Range和Pass作为固定效应
        if(fix.factor == "all"){
            message('asr <- asreml(trait ~ Range + Pass,random = ~idv(Name),
                              residual = ~ar1(Range):ar1(Pass), data = datdf)\n')
            asr <- asreml(trait ~ Range + Pass, random = ~idv(Name),
                          residual = ~ar1(Range):ar1(Pass), data = datdf)
        }
        #特殊情形，指定Range或Pass为固定效应
        if(fix.factor == "Range"){
            message('asr <- asreml(trait ~ Range + Pass,random = ~idv(Name),
                              residual = ~ar1(Range):ar1(Pass), data = datdf)\n')
            asr <- asreml(trait ~ Range, random = ~idv(Name),
                          residual = ~ar1(Range):ar1(Pass), data = datdf)
        }
        if(fix.factor == "Pass"){
            message('asr <- asreml(trait ~ Range + Pass,random = ~idv(Name),
                              residual = ~ar1(Range):ar1(Pass), data = datdf)\n')
            asr <- asreml(trait ~ Pass, random = ~idv(Name),
                          residual = ~ar1(Range):ar1(Pass), data = datdf)
        }
    }
    iter <- 1
    while(!asr$converge & (iter < 10)){
        message("更新 asr 迭代第 ", iter, " 次")
        asr  <- update(asr)
        iter <- iter + 1
    }
    print(wald(asr))
    summary(asr)$varcomp
    H2          <- vpredict(asr,H2~V1/(V1+V2))#遗传力
    H2$Location <- unique(datdf$Location)[1]
    H2$Field    <- unique(datdf$Field)[1]
    H2$Type     <- unique(datdf$Type)[1]
    H2$N        <- nrow(datdf)
    H2

    blue <- predict(asr, classify = "Name",pworkspace="800mb",data=datdf)$pvals

    if(nrow(blue[!is.na(blue$predicted.value),])!=0){
        blue          <- blue[blue$Name!='0',]
        blue$Location <- unique(datdf$Location)[1]
        blue$Field    <- unique(datdf$Field)[1]
        blue$Type     <- unique(datdf$Type)[1]
        blue$N        <- nrow(datdf)
        blue$converge <- asr$converge
    } else {
        blue           <- data.frame(asr$coefficients$random)
        names(blue)[1] <- 'predicted.value'
        newcol         <- stringsplit(row.names(blue),'_')
        blue$Name      <- newcol$X2
        blue           <- blue[,c(2,1)]
        blue$std.error <- 'NA'
        blue$status    <- 'NA'
        blue$Location  <- unique(datdf$Location)[1]
        blue$Field     <- unique(datdf$Field)[1]
        blue$N         <- nrow(datdf)
        blue$converge  <- asr$converge

    }
    head(blue)

    blue          <- blue[blue$Name!='0',]
    blue$Location <- unique(datdf$Location)[1]
    blue$Field    <- unique(datdf$Field)[1]
    blue$Type     <- unique(datdf$Type)[1]
    blue$N        <- nrow(datdf)
    blue$converge <- asr$converge
    head(blue)

    if(verbose){
        title <- paste(trait,'BLUE: Location =',
                       unique(datdf$Location)[1],
                       ' Field =',unique(datdf$Field)[1],
                       ' H2 =',round(H2[1,1],2),'N =',nrow(datdf),
                       '\n')
        qqnorm(blue$predicted.value,main=title)
        qqline(blue$predicted.value)
        hist(blue$predicted.value,main = title)
    }

    blue    <-subset(blue,substr(blue$Name,1,5)!='DUMMY')
    outlist <- list(H2=H2,blue=blue,asr=asr)
    message('ASREML estimation is successful...\n')
    return (outlist)
}

#' BLUP analysis
#'
#' The function is used for preliminary filtering of raw data, including:
#'
#' @param datdf
#' @param trait
#' @param na.max
#' @param fix.factor
#' @param min.valid.range
#' @param min.valid.pass
#' @param verbose
#' @return
#' @examples
#' @export blupEstimation

blupEstimation <- function(datdf, trait, na.max = 0.9, fix.factor = "all", min.valid.range = 2, min.valid.pass = 2, verbose = TRUE){

}


phenoHeatMap <- function(dat, trait_name = ""){
    NRange = length(table(dat$Range))
    NPass  = length(table(dat$Pass))
    phenoMat <- matrix(NA, nrow = NRange, ncol = NPass)
    phenoMat <- as.data.frame(phenoMat)
    row.names(phenoMat) <- unique(dat$Range)
    colnames(phenoMat)  <- unique(dat$Pass)
    Info <- paste0(dat$Range,"-",dat$Pass)
    for (i in 1:length(Info)) {
        splitTmp <- unlist(strsplit(Info[i], "-"))
        col_Idx <- which(colnames(phenoMat) == splitTmp[2])
        row_Idx <- which(row.names(phenoMat) == splitTmp[1])
        phenoMat[row_Idx, col_Idx] = dat[i,8]
        if(is.na(dat[i,8])){
            phenoMat[row_Idx, col_Idx] = -9
        }
    }
    pheatmap(phenoMat, show_rownames=T, cluster_rows = F, cluster_cols = F,
             main = paste0(trait_name, " Trait")
             # , col = coul
    )
}

# replicationCheck <- function(df){
#     q <- data.frame(table(daf$aa))
#     return (nrow(q[q$Freq>1,])/nrow(q))
# }

